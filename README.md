# Python Flask Web App on Google Cloud Run

This project is a simple "Hello World" web application using the Python Flask framework, designed to demonstrate best practices for deployment on Google Cloud Run.

## Technology Stack & Architectural Choices

This project makes several modern and deliberate technology choices for robustness and maintainability.

### Core Technologies
- **Language:** Python 3.13
- **Web Framework:** [Flask](https://flask.palletspro.com/) - A lightweight and popular micro-framework for building web applications in Python.

### Dependency Management
- **Package Manager:** [uv](https://github.com/astral-sh/uv)
- **Configuration:** Dependencies are managed in the `pyproject.toml` file.
- **Deployment:** The `requirements.txt` file is generated from `pyproject.toml` using `uv pip compile`. This provides the speed and modern ergonomics of `uv` for local development while maintaining compatibility with Google Cloud Buildpacks, which use the standard `requirements.txt`.

### WSGI Server
- **Production:** [Gunicorn](https://gunicorn.org/) - A robust, production-ready WSGI HTTP Server for UNIX. It is specified in the `Procfile` and is used by Cloud Run to serve the application.
- **Development:** The standard Flask development server is used for local development for its ease of use and powerful debugging features. This is run via the `if __name__ == '__main__':` block in `app.py`.

### Deployment
- **Platform:** [Google Cloud Run](https://cloud.google.com/run)
- **Method:** **Source Deployment**. We provide the source code directly to Cloud Run, and Google's Buildpacks automatically detect the Python language, install dependencies from `requirements.txt`, and run the application using the command from the `Procfile`.

## Project Structure
```
.
├── app.py              # Main Flask application logic
├── Procfile            # Specifies the command for Cloud Run to start the web server (Gunicorn)
├── pyproject.toml      # Project definition and dependencies for `uv`
└── requirements.txt    # Frozen dependencies for production, generated by `uv`
```

## How to Run Locally
1. **Install `uv`**:
   Follow the official instructions to install `uv`.

2. **Create a virtual environment**:
   ```bash
   uv venv
   ```

3. **Activate the virtual environment**:
   ```bash
   source .venv/bin/activate
   ```

4. **Install dependencies**:
   ```bash
   uv pip sync
   ```

5. **Run the development server**:
   ```bash
   python app.py
   ```
   The application will be available at `http://127.0.0.1:8080`.

## How to Deploy
This project is deployed to Google Cloud Run. While this can be done via the Gemini CLI, you can also deploy manually using the `gcloud` CLI:
```bash
gcloud run deploy gemini-cloudrun-app \
  --source . \
  --project=culture-guide \
  --region=us-west1
```

## Future Architecture Considerations

### When to use a Dockerfile?
While source deployment is convenient, a custom `Dockerfile` would be necessary if the application requires:
- **System-level dependencies** (e.g., `ffmpeg`, `imagemagick`).
- A highly specific version of Python not available in standard buildpacks.
- A complex build process not supported by buildpacks.
- Guaranteed environment parity between local development and production.

### How to Handle Private Dependencies?
If this project needed to use an in-house Python library, the following options were considered:
- **Vendoring:** Copying the library's source code directly into this project. Simple, but poor for maintainability.
- **Private Git Repository:** Installing the dependency directly from a private Git repository (e.g., on GitHub or Google Cloud Source Repositories). Requires configuring Cloud Build with access credentials.
- **Private Package Registry:** Publishing the library to a private registry like **Google Cloud Artifact Registry**. This is the most robust and scalable solution for enterprise-grade projects.
